## 一、Webpack 解决了什么问题

如何在前端项目中更高效地管理和维护项目中的每一个资源。

### 1、模块化的推进过程

#### stage1：早期的文件划分，使用 script 标签全局引入一个模块。

问题：
- 模块直接作用在全局，大量模块成员会污染了全局作用域；
- 没有私有空间，模块内部的成员都可以在外部被访问和修改；
- 模块越来越多，可能存在模块或者模块成员的命名冲突；
- 维护过程中很难辨别某个成员属于哪个模块；
- 无法管理模块与模块间的依赖关系；

#### stage2：命名空间方式

每个模块只允许暴露一个全局对象，将每个模块成员都包裹在这个全局对象中，这样可以实现私有的命名空间。

#### stage3：IIFE

利用立即执行函数形成一个私有的作用域，需要暴露给全局的变量和方法保存在一个全局的对象中。

#### state4: IIFE 依赖参数

将依赖作为参数传入模块内部

**问题：模块加载**

### 2、模块化规范

需求：

- 一个统一的模块化标准规范；
- 一个可以自动加载模块的基础库；

#### 1.CommonJs 规范

Node.js 中遵循的模块规范；（同步机制？）

该规范约定了一个文件就是一个模块，每个模块都有单独的作用域；

语法：
- 通过 module.exports 导出模块；
- 通过 require 函数载入模块；

#### 2.AMD（Asynchronous Module Definition) 异步模块定义规范（社区提出）

浏览器端的模块化标准

模块加载器 库工具：Require.js

``` shell
// AMD 规范 define 定义一个模块
define(['jquery', './module-a.js'], function($, moduleA) {
  return {
    start: function() {
      $('body).animate({ margin: '20px' });
      moduleA();
    }
  }
});

// AMD 规范载入一个模块
// require 会自动创建一个 script 标签，并执行相应模块的代码
require(['./module-a.js', function(moduleA) {
  moduleA();
}]);
```

**存在的问题：**
- 相对复杂；
- 一个页面会引入相同的依赖，导致应用加载过慢

#### 3.CMD

### 3、最佳实践

- Node.js 环境下使用 CommonJs 规范；
- 浏览器环境下使用 ES Modules 规范；（ES6 标准，存在浏览器兼容问题）

### 4、ES Modules 规范

问题：
- 浏览器兼容问题；
- 浏览器频繁发送网络请求；
- html、css 等资源也存在模块化问题；

### 5、模块打包工具

需求点（功能点）：

- 代码编译能力：开发阶段 ES6 -> 生产阶段 ES5；
    解决浏览器兼容问题。
- js 模块打包能力：开发阶段散落的模块 -> 生产阶段 bundle.js；
    解决浏览器频繁发送网络请求问题。
- 其他资源模块化（打包）能力：开发阶段 .css、.scss、.less -> 生产阶段 .css；
    解决非 js 资源的模块化问题。
    gulp 很难解决，故 Webpack 成为主流前端模块化打包工具。

